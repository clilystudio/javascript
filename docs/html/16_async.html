<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="css/normalize.css" />
    <link rel="stylesheet" href="css/app.css" />
    <title>异步操作和Async函数</title>
</head>
<body>
<div id="content">
<h1 id="-async-">异步操作和Async函数</h1><ol class="content-toc" id="content-toc"><li data-src="基本概念" class="link"><a href="#基本概念">基本概念</a></li><li data-src="Generator函数" class="link"><a href="#Generator函数">Generator函数</a></li><li data-src="Thunk函数" class="link"><a href="#Thunk函数">Thunk函数</a></li><li data-src="co模块" class="link"><a href="#co模块">co模块</a></li><li data-src="async函数" class="link"><a href="#async函数">async函数</a></li><li data-src="异步遍历器" class="link"><a href="#异步遍历器">异步遍历器</a></li></ol>
<p>异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>ES6将JavaScript异步编程带入了一个全新的阶段，ES7的<code>Async</code>函数更是提出了异步编程的终极解决方案。</p>
<h2 id="基本概念"><a id="基本概念" />基本概念</h2>
<h3 id="异步" class="异步">异步</h3>
<p>所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h3 id="回调函数" class="回调函数">回调函数</h3>
<p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是"重新调用"。</p>
<p>读取文件进行处理，是这样写的。</p>
<pre class=" language-javascript"><code class=" language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/passwd'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="Promise" class="Promise">Promise</h3>
<p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<pre class=" language-javascript"><code class=" language-javascript">fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileA<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileB<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // ...
</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数噩梦"（callback hell）。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> readFile <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs-readfile-promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">readFile<span class="token punctuation">(</span></span>fileA<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>data<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">readFile<span class="token punctuation">(</span></span>fileB<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>data<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h2 id="Generator函数"><a id="Generator函数" />Generator函数</h2>
<h3 id="协程" class="协程">协程</h3>
<p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程A开始执行。</li>
<li>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>第三步，（一段时间后）协程B交还执行权。</li>
<li>第四步，协程A恢复执行。</li>
</ul>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">asyncJob<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // ...其他代码
</span>  <span class="token keyword">var</span> f <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span>fileA<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // ...其他代码
</span><span class="token punctuation">}</span>
</code></pre>
<p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p>
<p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="Generator函数的概念" class="Generator函数的概念">Generator函数的概念</h3>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator函数的执行方法如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> yield x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // { value: 3, done: false }
</span>g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // { value: undefined, done: true }
</span></code></pre>
<p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到<code>x + 2</code>为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="Generator函数的数据交换和错误处理" class="Generator函数的数据交换和错误处理">Generator函数的数据交换和错误处理</h3>
<p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> y <span class="token operator">=</span> yield x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // { value: 3, done: false }
</span>g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // { value: 2, done: true }
</span></code></pre>
<p>上面代码中，第一个next方法的value属性，返回表达式<code>x + 2</code>的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> yield x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 出错了
</span></code></pre>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try ...catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="异步任务的封装" class="异步任务的封装">异步任务的封装</h3>
<p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> fetch <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'node-fetch'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">'https://api.github.com/users/github'</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> yield <span class="token function">fetch<span class="token punctuation">(</span></span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>result<span class="token punctuation">.</span>bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">json<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h2 id="Thunk函数"><a id="Thunk函数" />Thunk函数</h2>
<h3 id="参数的求值策略" class="参数的求值策略">参数的求值策略</h3>
<p>Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是"求值策略"，即函数的参数到底应该何时求值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> m <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span>x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span>
</code></pre>
<p>上面代码先定义函数f，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p>
<p>一种意见是"传值调用"（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">f<span class="token punctuation">(</span></span>x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 传值调用时，等同于
</span><span class="token function">f<span class="token punctuation">(</span></span><span class="token number">6</span><span class="token punctuation">)</span>
</code></pre>
<p>另一种意见是"传名调用"（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">f<span class="token punctuation">(</span></span>x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 传名调用时，等同于
</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span>
</code></pre>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token number">3</span> <span class="token operator">*</span> x <span class="token operator">*</span> x <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于"传名调用"，即只在执行时求值。</p>
<h3 id="Thunk函数的含义" class="Thunk函数的含义">Thunk函数的含义</h3>
<p>编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>m<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> m <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span>x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 等同于
</span>
<span class="token keyword">var</span> thunk <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>thunk<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">thunk<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，函数f的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p>
<p>这就是Thunk函数的定义，它是"传名调用"的一种实现策略，用来替换某个表达式。</p>
<h3 id="JavaScript语言的Thunk函数" class="JavaScript语言的Thunk函数">JavaScript语言的Thunk函数</h3>
<p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 正常版本的readFile（多参数版本）
</span>fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileName<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// Thunk版本的readFile（单参数版本）
</span><span class="token keyword">var</span> readFileThunk <span class="token operator">=</span> <span class="token function">Thunk<span class="token punctuation">(</span></span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">readFileThunk<span class="token punctuation">(</span></span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> Thunk <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileName<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// ES5版本
</span><span class="token keyword">var</span> Thunk <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
      args<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply<span class="token punctuation">(</span></span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// ES6版本
</span><span class="token keyword">var</span> Thunk <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> readFileThunk <span class="token operator">=</span> <span class="token function">Thunk<span class="token punctuation">(</span></span>fs<span class="token punctuation">.</span>readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">readFileThunk<span class="token punctuation">(</span></span>fileA<span class="token punctuation">)</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>下面是另一个完整的例子。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>a<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">cb<span class="token punctuation">(</span></span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> ft <span class="token operator">=</span> <span class="token function">Thunk<span class="token punctuation">(</span></span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> log <span class="token operator">=</span> console<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">bind<span class="token punctuation">(</span></span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ft<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 1
</span></code></pre>
<h3 id="Thunkify模块" class="Thunkify模块">Thunkify模块</h3>
<p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>首先是安装。</p>
<pre class=" language-bash"><code class=" language-bash">$ npm install thunkify
</code></pre>
<p>使用方式如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> thunkify <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'thunkify'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> read <span class="token operator">=</span> <span class="token function">thunkify<span class="token punctuation">(</span></span>fs<span class="token punctuation">.</span>readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">read<span class="token punctuation">(</span></span><span class="token string">'package.json'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // ...
</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Thunkify的源码与上一节那个简单的转换器非常像。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">thunkify<span class="token punctuation">(</span></span>fn<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">var</span> called<span class="token punctuation">;</span>

      args<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        done<span class="token punctuation">.</span><span class="token function">apply<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        fn<span class="token punctuation">.</span><span class="token function">apply<span class="token punctuation">(</span></span>ctx<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">done<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
  <span class="token function">callback<span class="token punctuation">(</span></span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">callback<span class="token punctuation">(</span></span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> ft <span class="token operator">=</span> <span class="token function">thunkify<span class="token punctuation">(</span></span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> print <span class="token operator">=</span> console<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">bind<span class="token punctuation">(</span></span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">ft<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 3
</span></code></pre>
<p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p>
<h3 id="Generator-函数的流程管理" class="Generator-函数的流程管理">Generator 函数的流程管理</h3>
<p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p>Generator函数可以自动执行。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // ...
</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>res<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，Generator函数<code>gen</code>会自动执行完所有步骤。</p>
<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用处。以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> thunkify <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'thunkify'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> readFile <span class="token operator">=</span> <span class="token function">thunkify<span class="token punctuation">(</span></span>fs<span class="token punctuation">.</span>readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> r1 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>r1<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> r2 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>r2<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> r1 <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r1<span class="token punctuation">.</span><span class="token function">value<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
  <span class="token keyword">var</span> r2 <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  r2<span class="token punctuation">.</span><span class="token function">value<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
    g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p>
<p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
<h3 id="Thunk函数的自动流程管理" class="Thunk函数的自动流程管理">Thunk函数的自动流程管理</h3>
<p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">run<span class="token punctuation">(</span></span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token function">fn<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">next<span class="token punctuation">(</span></span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">value<span class="token punctuation">(</span></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">g<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // ...
</span><span class="token punctuation">}</span>

<span class="token function">run<span class="token punctuation">(</span></span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码的<code>run</code>函数，就是一个Generator函数的自动执行器。内部的<code>next</code>函数就是Thunk的回调函数。<code>next</code>函数先将指针移到Generator函数的下一步（<code>gen.next</code>方法），然后判断Generator函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入Thunk函数（<code>result.value</code>属性），否则就直接退出。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在<code>yield</code>命令后面的必须是Thunk函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'fileA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'fileB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // ...
</span>  <span class="token keyword">var</span> fn <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'fileN'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">run<span class="token punctuation">(</span></span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="co模块"><a id="co模块" />co模块</h2>
<h3 id="基本用法" class="基本用法">基本用法</h3>
<p><a href="https://github.com/tj/co">co模块</a>是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p>比如，有一个Generator函数，用于依次读取两个文件。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f1<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f2<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>co模块可以让你不用编写Generator函数的执行器。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> co <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'co'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">co<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">co<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'Generator 函数执行完成'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h3 id="co模块的原理" class="co模块的原理">co模块的原理</h3>
<p>为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</p>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h3 id="基于Promise对象的自动执行" class="基于Promise对象的自动执行">基于Promise对象的自动执行</h3>
<p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> readFile <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileName<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">reject<span class="token punctuation">(</span></span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f1<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f2<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>然后，手动执行上面的Generator函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
  g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">run<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">next<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">run<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h3 id="co模块的源码" class="co模块的源码">co模块的源码</h3>
<p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">co<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">co<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> gen <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gen <span class="token operator">||</span> <span class="token keyword">typeof</span> gen<span class="token punctuation">.</span>next <span class="token operator">!</span><span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">resolve<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">co<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> gen <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>gen <span class="token operator">||</span> <span class="token keyword">typeof</span> gen<span class="token punctuation">.</span>next <span class="token operator">!</span><span class="token operator">==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">resolve<span class="token punctuation">(</span></span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">onFulfilled<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">onFulfilled<span class="token punctuation">(</span></span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> ret<span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">next<span class="token punctuation">(</span></span>ret<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>最后，就是关键的next函数，它会反复调用自身。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">next<span class="token punctuation">(</span></span>ret<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">resolve<span class="token punctuation">(</span></span>ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> value <span class="token operator">=</span> toPromise<span class="token punctuation">.</span><span class="token function">call<span class="token punctuation">(</span></span>ctx<span class="token punctuation">,</span> ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&amp;&amp;</span> <span class="token function">isPromise<span class="token punctuation">(</span></span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token function">onRejected<span class="token punctuation">(</span></span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'You may only yield a function, promise, generator, array, or object, '</span>
    <span class="token operator">+</span> <span class="token string">'but the following object was passed: "'</span> <span class="token operator">+</span> <span class="token function">String<span class="token punctuation">(</span></span>ret<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'"'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
<h3 id="处理并发的异步操作" class="处理并发的异步操作">处理并发的异步操作</h3>
<p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 数组的写法
</span><span class="token function">co<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> yield <span class="token punctuation">[</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 对象的写法
</span><span class="token function">co<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> res <span class="token operator">=</span> yield <span class="token punctuation">{</span>
    <span class="token number">1</span><span class="token punctuation">:</span> Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token number">2</span><span class="token punctuation">:</span> Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>下面是另一个例子。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">co<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> values <span class="token operator">=</span> <span class="token punctuation">[</span>n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> n3<span class="token punctuation">]</span><span class="token punctuation">;</span>
  yield values<span class="token punctuation">.</span><span class="token function">map<span class="token punctuation">(</span></span>somethingAsync<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">somethingAsync<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // do something async
</span>  <span class="token keyword">return</span> y
<span class="token punctuation">}</span>
</code></pre>
<p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p>
<h2 id="async函数"><a id="async函数" />async函数</h2>
<h3 id="含义" class="含义">含义</h3>
<p>ES7提供了<code>async</code>函数，使得异步操作变得更加方便。<code>async</code>函数是什么？一句话，<code>async</code>函数就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> readFile <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fileName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fs<span class="token punctuation">.</span><span class="token function">readFile<span class="token punctuation">(</span></span>fileName<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token function">reject<span class="token punctuation">(</span></span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">resolve<span class="token punctuation">(</span></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> yield <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f1<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f2<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>写成<code>async</code>函数，就是下面这样。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> asyncReadFile <span class="token operator">=</span> async <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> await <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/fstab'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> await <span class="token function">readFile<span class="token punctuation">(</span></span><span class="token string">'/etc/shells'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f1<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>f2<span class="token punctuation">.</span><span class="token function">toString<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>一比较就会发现，<code>async</code>函数就是将Generator函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。Generator函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">asyncReadFile<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能得到真正执行，得到最后结果。</p>
<p>（2）更好的语义。<code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。 <code>co</code>模块约定，<code>yield</code>命令后面只能是Thunk函数或Promise对象，而<code>async</code>函数的<code>await</code>命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
<p>（4）返回值是Promise。<code>async</code>函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个Promise对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p>
<h3 id="语法" class="语法">语法</h3>
<p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<p>（1）<code>async</code>函数返回一个Promise对象。</p>
<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// "hello world"
</span></code></pre>
<p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p>
<p><code>async</code>函数内部抛出错误，会导致返回的Promise对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>
  v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">,</span>
  e <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// Error: 出错了
</span></code></pre>
<p>（2）<code>async</code>函数返回的Promise对象，必须等到内部所有<code>await</code>命令的Promise对象执行完，才会发生状态改变。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
<p>下面是一个例子。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">getTitle<span class="token punctuation">(</span></span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> response <span class="token operator">=</span> await <span class="token function">fetch<span class="token punctuation">(</span></span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> html <span class="token operator">=</span> await response<span class="token punctuation">.</span><span class="token function">text<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> html<span class="token punctuation">.</span><span class="token function">match<span class="token punctuation">(</span></span><span class="token regex">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">getTitle<span class="token punctuation">(</span></span><span class="token string">'https://tc39.github.io/ecma262/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// "ECMAScript 2017 Language Specification"
</span></code></pre>
<p>（3）正常情况下，<code>await</code>命令后面是一个Promise对象。如果不是，会被转成一个立即<code>resolve</code>的Promise对象。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> await <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 123
</span></code></pre>
<p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，它被转成Promise对象，并立即<code>resolve</code>。</p>
<p><code>await</code>命令后面的Promise对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await Promise<span class="token punctuation">.</span><span class="token function">reject<span class="token punctuation">(</span></span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 出错了
</span></code></pre>
<p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p>
<p>只要一个<code>await</code>语句后面的Promise变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await Promise<span class="token punctuation">.</span><span class="token function">reject<span class="token punctuation">(</span></span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  await Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 不会执行
</span><span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p>
<p>为了避免这个问题，可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样第二个<code>await</code>就会执行。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    await Promise<span class="token punctuation">.</span><span class="token function">reject<span class="token punctuation">(</span></span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> await Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// hello world
</span></code></pre>
<p>另一种方法是<code>await</code>后面的Promise对象再跟一个<code>catch</code>方面，处理前面可能出现的错误。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await Promise<span class="token punctuation">.</span><span class="token function">reject<span class="token punctuation">(</span></span><span class="token string">'出错了'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> await Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 出错了
</span><span class="token comment" spellcheck="true">// hello world
</span></code></pre>
<p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">main<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> val1 <span class="token operator">=</span> await <span class="token function">firstStep<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> val2 <span class="token operator">=</span> await <span class="token function">secondStep<span class="token punctuation">(</span></span>val1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> val3 <span class="token operator">=</span> await <span class="token function">thirdStep<span class="token punctuation">(</span></span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'Final: '</span><span class="token punctuation">,</span> val3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>（4）如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的Promise对象被<code>reject</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>v <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// Error：出错了
</span></code></pre>
<p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的Promise对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。</p>
<p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    await <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'出错了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">await<span class="token punctuation">(</span></span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="async函数的实现" class="async函数的实现">async函数的实现</h3>
<p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">fn<span class="token punctuation">(</span></span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // ...
</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 等同于
</span>
<span class="token keyword">function</span> <span class="token function">fn<span class="token punctuation">(</span></span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">spawn<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true"> // ...
</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">spawn<span class="token punctuation">(</span></span>genF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token function">genF<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">step<span class="token punctuation">(</span></span>nextF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> next <span class="token operator">=</span> <span class="token function">nextF<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">resolve<span class="token punctuation">(</span></span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">step<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">step<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token keyword">throw</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">step<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>async</code>函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器<code>Babel</code>和<code>regenerator</code>都已经支持，转码后就能使用。</p>
<h3 id="async-函数的用法" class="async-函数的用法">async 函数的用法</h3>
<p><code>async</code>函数返回一个Promise对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">getStockPriceByName<span class="token punctuation">(</span></span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> symbol <span class="token operator">=</span> await <span class="token function">getStockSymbol<span class="token punctuation">(</span></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> stockPrice <span class="token operator">=</span> await <span class="token function">getStockPrice<span class="token punctuation">(</span></span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> stockPrice<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getStockPriceByName<span class="token punctuation">(</span></span><span class="token string">'goog'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">timeout<span class="token punctuation">(</span></span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout<span class="token punctuation">(</span></span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

async <span class="token keyword">function</span> <span class="token function">asyncPrint<span class="token punctuation">(</span></span>value<span class="token punctuation">,</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await <span class="token function">timeout<span class="token punctuation">(</span></span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">asyncPrint<span class="token punctuation">(</span></span><span class="token string">'hello world'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码指定50毫秒以后，输出"hello world"。</p>
<p>Async函数有多种使用形式。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 函数声明
</span>async <span class="token keyword">function</span> <span class="token function">foo<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 函数表达式
</span>const foo <span class="token operator">=</span> async <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 对象的方法
</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> async <span class="token function">foo<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 箭头函数
</span>const foo <span class="token operator">=</span> async <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="注意点" class="注意点">注意点</h3>
<p>第一点，<code>await</code>命令后面的Promise对象，运行结果可能是rejected，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">myFunction<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    await <span class="token function">somethingThatReturnsAPromise<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 另一种写法
</span>
async <span class="token keyword">function</span> <span class="token function">myFunction<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  await <span class="token function">somethingThatReturnsAPromise<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> foo <span class="token operator">=</span> await <span class="token function">getFoo<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> await <span class="token function">getBar<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 写法一
</span><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span> <span class="token operator">=</span> await Promise<span class="token punctuation">.</span><span class="token function">all<span class="token punctuation">(</span></span><span class="token punctuation">[</span><span class="token function">getFoo<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBar<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 写法二
</span><span class="token keyword">let</span> fooPromise <span class="token operator">=</span> <span class="token function">getFoo<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> barPromise <span class="token operator">=</span> <span class="token function">getBar<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> await fooPromise<span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> await barPromise<span class="token punctuation">;</span>
</code></pre>
<p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">dbFuc<span class="token punctuation">(</span></span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // 报错
</span>  docs<span class="token punctuation">.</span><span class="token function">forEach<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    await db<span class="token punctuation">.</span><span class="token function">post<span class="token punctuation">(</span></span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码会报错，因为await用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">dbFuc<span class="token punctuation">(</span></span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // 可能得到错误结果
</span>  docs<span class="token punctuation">.</span><span class="token function">forEach<span class="token punctuation">(</span></span>async <span class="token keyword">function</span> <span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    await db<span class="token punctuation">.</span><span class="token function">post<span class="token punctuation">(</span></span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">dbFuc<span class="token punctuation">(</span></span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> doc of docs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    await db<span class="token punctuation">.</span><span class="token function">post<span class="token punctuation">(</span></span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">dbFuc<span class="token punctuation">(</span></span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map<span class="token punctuation">(</span></span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> db<span class="token punctuation">.</span><span class="token function">post<span class="token punctuation">(</span></span>doc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> results <span class="token operator">=</span> await Promise<span class="token punctuation">.</span><span class="token function">all<span class="token punctuation">(</span></span>promises<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 或者使用下面的写法
</span>
async <span class="token keyword">function</span> <span class="token function">dbFuc<span class="token punctuation">(</span></span>db<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> promises <span class="token operator">=</span> docs<span class="token punctuation">.</span><span class="token function">map<span class="token punctuation">(</span></span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> db<span class="token punctuation">.</span><span class="token function">post<span class="token punctuation">(</span></span>doc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> promise of promises<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    results<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>await promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>ES6将<code>await</code>增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
<h3 id="与Promise、Generator的比较" class="与Promise、Generator的比较">与Promise、Generator的比较</h3>
<p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是Promise的写法。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">chainAnimationsPromise<span class="token punctuation">(</span></span>elem<span class="token punctuation">,</span> animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>

 <span class="token comment" spellcheck="true"> // 变量ret用来保存上一个动画的返回值
</span>  <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // 新建一个空的Promise
</span>  <span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true"> // 使用then方法，添加所有动画
</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> anim of animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    p <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ret <span class="token operator">=</span> val<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">anim<span class="token punctuation">(</span></span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token comment" spellcheck="true"> // 返回一个部署了错误捕捉机制的Promise
</span>  <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* 忽略错误，继续执行 */</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是Generator函数的写法。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">chainAnimationsGenerator<span class="token punctuation">(</span></span>elem<span class="token punctuation">,</span> animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">return</span> <span class="token function">spawn<span class="token punctuation">(</span></span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> anim of animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> yield <span class="token function">anim<span class="token punctuation">(</span></span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">/* 忽略错误，继续执行 */</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre>
<p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p>最后是Async函数的写法。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">chainAnimationsAsync<span class="token punctuation">(</span></span>elem<span class="token punctuation">,</span> animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> anim of animations<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ret <span class="token operator">=</span> await <span class="token function">anim<span class="token punctuation">(</span></span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/* 忽略错误，继续执行 */</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>
<h2 id="异步遍历器"><a id="异步遍历器" />异步遍历器</h2>
<p>《遍历器》一章说过，Iterator接口是一种数据遍历的协议，只要调用遍历器对象的<code>next</code>方法，就会得到一个表示当前成员信息的对象<code>{value, done}</code>。其中，<code>value</code>表示当前的数据的值，<code>done</code>是一个布尔值，表示遍历是否结束。</p>
<p>这隐含着规定，<code>next</code>方法是同步的，只要调用就必须立刻返回值。也就是说，一旦执行<code>next</code>方法，就必须同步地得到<code>value</code>和<code>done</code>这两方面的信息。这对于同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator函数里面的异步操作，返回一个Thunk函数或者Promise对象，即<code>value</code>属性是一个Thunk函数或者Promise对象，等待以后返回真正的值，而<code>done</code>属性则还是同步产生的。</p>
<p>目前，有一个<a href="https://github.com/tc39/proposal-async-iteration">提案</a>，为异步操作提供原生的遍历器接口，即<code>value</code>和<code>done</code>这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。</p>
<h3 id="异步遍历的接口" class="异步遍历的接口">异步遍历的接口</h3>
<p>异步遍历器的最大的语法特点，就是调用遍历器的<code>next</code>方法，返回的是一个Promise对象。</p>
<pre class=" language-javascript"><code class=" language-javascript">asyncIterator
  <span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>
    <span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">,</span> done <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token comment" spellcheck="true">/* ... */</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>asyncIterator</code>是一个异步遍历器，调用<code>next</code>方法以后，返回一个Promise对象。因此，可以使用<code>then</code>方法指定，这个Promise对象的状态变为<code>resolve</code>以后的回调函数。回调函数的参数，则是一个具有<code>value</code>和<code>done</code>两个属性的对象，这个跟同步遍历器是一样的。</p>
<p>我们知道，一个对象的同步遍历器的接口，部署在<code>Symbol.iterator</code>属性上面。同样地，对象的异步遍历器接口，部署在<code>Symbol.asyncIterator</code>属性上面。不管是什么样的对象，只要它的<code>Symbol.asyncIterator</code>属性有值，就表示应该对它进行异步遍历。</p>
<p>下面是一个异步遍历器的例子。</p>
<pre class=" language-javascript"><code class=" language-javascript">const asyncIterable <span class="token operator">=</span> <span class="token function">createAsyncIterable<span class="token punctuation">(</span></span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const asyncIterator <span class="token operator">=</span> someCollection<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>iterResult1 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>iterResult1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // { value: 'a', done: false }
</span>  <span class="token keyword">return</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>iterResult2 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>iterResult2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // { value: 'b', done: false }
</span>  <span class="token keyword">return</span> asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span>iterResult3 <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>iterResult3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // { value: undefined, done: true }
</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个Promise对象；等到Promise对象<code>resolve</code>了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回Promise对象，作为中介。</p>
<p>由于异步遍历器的<code>next</code>方法，返回的是一个Promise对象。因此，可以把它放在<code>await</code>命令后面。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const asyncIterable <span class="token operator">=</span> <span class="token function">createAsyncIterable<span class="token punctuation">(</span></span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const asyncIterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>await asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // { value: 'a', done: false }
</span>  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>await asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // { value: 'b', done: false }
</span>  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>await asyncIterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment" spellcheck="true"> // { value: undefined, done: true }
</span><span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>next</code>方法用<code>await</code>处理以后，就不必使用<code>then</code>方法了。整个流程已经很接近同步处理了。</p>
<p>注意，异步遍历器的<code>next</code>方法是可以连续调用的，不必等到上一步产生的Promise对象<code>resolve</code>以后再调用。这种情况下，<code>next</code>方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的<code>next</code>方法放在<code>Promise.all</code>方法里面。</p>
<pre class=" language-javascript"><code class=" language-javascript">const asyncGenObj <span class="token operator">=</span> <span class="token function">createAsyncIterable<span class="token punctuation">(</span></span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const <span class="token punctuation">[</span><span class="token punctuation">{</span>value<span class="token punctuation">:</span> v1<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> v2<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">=</span> await Promise<span class="token punctuation">.</span><span class="token function">all<span class="token punctuation">(</span></span><span class="token punctuation">[</span>
  asyncGenObj<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> asyncGenObj<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // a b
</span></code></pre>
<p>另一种用法是一次性调用所有的<code>next</code>方法，然后<code>await</code>最后一步操作。</p>
<pre class=" language-javascript"><code class=" language-javascript">const writer <span class="token operator">=</span> <span class="token function">openFile<span class="token punctuation">(</span></span><span class="token string">'someFile.txt'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
await writer<span class="token punctuation">.</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="for-await---of" class="for-await---of">for await...of</h3>
<p>前面介绍过，<code>for...of</code>循环用于遍历同步的Iterator接口。新引入的<code>for await...of</code>循环，则是用于遍历异步的Iterator接口。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> await <span class="token punctuation">(</span>const x of <span class="token function">createAsyncIterable<span class="token punctuation">(</span></span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">
// a
</span><span class="token comment" spellcheck="true">// b
</span></code></pre>
<p>上面代码中，<code>createAsyncIterable()</code>返回一个异步遍历器，<code>for...of</code>循环自动调用这个遍历器的<code>next</code>方法，会得到一个Promise对象。<code>await</code>用来处理这个Promise对象，一旦<code>resolve</code>，就把得到的值（<code>x</code>）传入<code>for...of</code>的循环体。</p>
<p>如果<code>next</code>方法返回的Promise对象被<code>reject</code>，那么就要用<code>try...catch</code>捕捉。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> await <span class="token punctuation">(</span>const x of <span class="token function">createRejectingIterable<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">error<span class="token punctuation">(</span></span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>注意，<code>for await...of</code>循环也可以用于同步遍历器。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">(</span>async <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> await <span class="token punctuation">(</span>const x of <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// a
</span><span class="token comment" spellcheck="true">// b
</span></code></pre>
<h3 id="异步Generator函数" class="异步Generator函数">异步Generator函数</h3>
<p>就像Generator函数返回一个同步遍历器对象一样，异步Generator函数的作用，是返回一个异步遍历器对象。</p>
<p>在语法上，异步Generator函数就是<code>async</code>函数与Generator函数的结合。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">readLines<span class="token punctuation">(</span></span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> file <span class="token operator">=</span> await <span class="token function">fileOpen<span class="token punctuation">(</span></span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span>EOF<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      yield await file<span class="token punctuation">.</span><span class="token function">readLine<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    await file<span class="token punctuation">.</span><span class="token function">close<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，异步操作前面使用<code>await</code>关键字标明，即<code>await</code>后面的操作，应该返回Promise对象。凡是使用<code>yield</code>关键字的地方，就是<code>next</code>方法的停下来的地方，它后面的表达式的值（即<code>await file.readLine()</code>的值），会作为<code>next()</code>返回对象的<code>value</code>属性，这一点是于同步Generator函数一致的。</p>
<p>可以像下面这样，使用上面代码定义的异步Generator函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">for</span> await <span class="token punctuation">(</span>const line of <span class="token function">readLines<span class="token punctuation">(</span></span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>异步Generator函数可以与<code>for await...of</code>循环结合起来使用。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">prefixLines<span class="token punctuation">(</span></span>asyncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> await <span class="token punctuation">(</span>const line of asyncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield <span class="token string">'&gt; '</span> <span class="token operator">+</span> line<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>yield</code>命令依然是立刻返回的，但是返回的是一个Promise对象。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncGenerator<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'Start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const result <span class="token operator">=</span> await <span class="token function">doSomethingAsync<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // (A)
</span>  yield <span class="token string">'Result: '</span><span class="token operator">+</span> result<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // (B)
</span>  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'Done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，调用<code>next</code>方法以后，会在<code>B</code>处暂停执行，<code>yield</code>命令立刻返回一个Promise对象。这个Promise对象不同于<code>A</code>处<code>await</code>命令后面的那个Promise对象。主要有两点不同，一是<code>A</code>处的Promise对象<code>resolve</code>以后产生的值，会放入<code>result</code>变量；二是<code>B</code>处的Promise对象<code>resolve</code>以后产生的值，是表达式<code>'Result： ' + result</code>的值；二是<code>A</code>处的Promise对象一定先于<code>B</code>处的Promise对象<code>resolve</code>。</p>
<p>如果异步Generator函数抛出错误，会被Promise对象<code>reject</code>，然后抛出的错误被<code>catch</code>方法捕获。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncGenerator<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Problem!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">asyncGenerator<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // Error: Problem!
</span></code></pre>
<p>注意，普通的<code>async</code>函数返回的是一个Promise对象，而异步Generator函数返回的是一个异步Iterator对象。基本上，可以这样理解，<code>async</code>函数和异步Generator函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过<code>for await...of</code>执行，或者自己编写执行器。下面就是一个异步Generator函数的执行器。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">takeAsync<span class="token punctuation">(</span></span>asyncIterable<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">Infinity</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  const iterator <span class="token operator">=</span> asyncIterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>asyncIterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    const <span class="token punctuation">{</span>value<span class="token punctuation">,</span>done<span class="token punctuation">}</span> <span class="token operator">=</span> await iterator<span class="token punctuation">.</span><span class="token function">next<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">push<span class="token punctuation">(</span></span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，异步Generator函数产生的异步遍历器，会通过<code>while</code>循环自动执行，每当<code>await iterator.next()</code>完成，就会进入下一轮循环。</p>
<p>下面是这个自动执行器的一个使用实例。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield <span class="token string">'a'</span><span class="token punctuation">;</span>
    yield <span class="token string">'b'</span><span class="token punctuation">;</span>
    yield <span class="token string">'c'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> await <span class="token function">takeAsync<span class="token punctuation">(</span></span><span class="token function">gen<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then<span class="token punctuation">(</span></span><span class="token keyword">function</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // ['a', 'b', 'c']
</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>异步Generator函数出现以后，JavaScript就有了四种函数形式：普通函数、<code>async</code>函数、Generator函数和异步Generator函数。请注意区分每种函数的不同之处。</p>
<p>最后，同步的数据结构，也可以使用异步Generator函数。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">createAsyncIterable<span class="token punctuation">(</span></span>syncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>const elem of syncIterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yield elem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，由于没有异步操作，所以也就没有使用<code>await</code>关键字。</p>
<h3 id="yield--语句" class="yield--语句">yield* 语句</h3>
<p><code>yield*</code>语句也可以跟一个异步遍历器。</p>
<pre class=" language-javascript"><code class=" language-javascript">async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen1<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  yield <span class="token string">'a'</span><span class="token punctuation">;</span>
  yield <span class="token string">'b'</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

async <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen2<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const result <span class="token operator">=</span> yield<span class="token operator">*</span> <span class="token function">gen1<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>gen2</code>函数里面的<code>result</code>变量，最后的值是<code>2</code>。</p>
<p>与同步Generator函数一样，<code>for await...of</code>循环会展开<code>yield*</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">(</span>async <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> await <span class="token punctuation">(</span>const x of <span class="token function">gen2<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// a
</span><span class="token comment" spellcheck="true">// b
</span></code></pre>
</div>
</body>
</html>
